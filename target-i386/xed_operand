int operand_is_mem(const xed_operand_enum_t op_name, uint32_t * mem_addr,
		   int operand_i)
{

	switch (op_name) {
		/* Memory */
	case XED_OPERAND_AGEN:
	case XED_OPERAND_MEM0:
	case XED_OPERAND_MEM1:{
			unsigned long base = 0;
			unsigned long index = 0;
			unsigned long scale = 1;
			unsigned long segbase = 0;
			unsigned short segsel = 0;
			unsigned long displacement = 0;
			unsigned int j;
			size_t remaining = 0;

			/* Set memory index */
			int mem_idx = 0;
			if (op_name == XED_OPERAND_MEM1)
				mem_idx = 1;

			unsigned int memlen =
			    xed_decoded_inst_operand_length(&xedd_g, operand_i);

			/* Initialization */
			base = 0;
			index = 0;
			scale = 1;
			segbase = 0;
			segsel = 0;
			displacement = 0;

			// Get Segment register
			xed_reg_enum_t seg_regid =
			    xed_decoded_inst_get_seg_reg(&xedd_g, mem_idx);

			if (seg_regid != XED_REG_INVALID) {
				const xed_operand_values_t *xopv =
				    xed_decoded_inst_operands_const(&xedd_g);
				xed_bool_t default_segment =
				    xed_operand_values_using_default_segment
				    (xopv, mem_idx);

				if (!default_segment) {
					int segmentreg =
					    xed_regmapping[seg_regid][0];

					segbase =
					    cpu_single_env->segs[segmentreg].base;
					segsel =
					    cpu_single_env->segs[segmentreg].selector;
				}
//          fprintf(tracelog,"memlen %d SEG %d %s, default_seg %d segbase %x, segsel %d ",memlen, seg_regid, \
				xed_reg_enum_t2str(seg_regid), default_segment,\
				    segbase, segsel);
			}

			// Get Base register
			xed_reg_enum_t base_regid =
			    xed_decoded_inst_get_base_reg(&xedd_g, mem_idx);
			
			basereg = base_regid;
			
			
			if (base_regid != XED_REG_INVALID) {
				int basereg =
				    xed_regmapping[base_regid][0];

				base = cpu_single_env->regs[basereg];
				
//          fprintf(tracelog,"BASE_REG %d %s, base %x ",base_regid, xed_reg_enum_t2str(base_regid), base);
			}
			// Get Index register and Scale
			xed_reg_enum_t index_regid =
			    xed_decoded_inst_get_index_reg(&xedd_g, mem_idx);
			if (mem_idx == 0 && index_regid != XED_REG_INVALID) {
				int indexreg =
				    xed_regmapping[index_regid][0];

				index = cpu_single_env->regs[indexreg];

				// Get Scale (AKA width) (only have a scale if the index exists)
				if (xed_decoded_inst_get_scale
				    (&xedd_g, operand_i) != 0) {
					scale =
					    (unsigned long)
					    xed_decoded_inst_get_scale(&xedd_g,
								       mem_idx);
				}
			}

			// Get displacement (AKA offset)
			displacement =
			    (unsigned long)
			    xed_decoded_inst_get_memory_displacement(&xedd_g,
								     mem_idx);
	

			
//        fprintf(tracelog,"INDEX_REG %d %s, index %x, scale %x, disp %x\n",index_regid,xed_reg_enum_t2str(index_regid), index, scale, displacement);
					
	// Calculate memory address accessed
			*mem_addr =
			    segbase + base + index * scale + displacement;
						
			return 1;
		}

	default:
		return 0;
	}

}

int operand_is_relbr(const xed_operand_enum_t op_name, uint32_t * branch) {
	switch (op_name) {
		/* Jumps */
	case XED_OPERAND_PTR:	// pointer (always in conjunction with a IMM0)
	case XED_OPERAND_RELBR:{
				// branch displacements

			xed_uint_t disp =
			    xed_decoded_inst_get_branch_displacement(&xedd_g);
			*branch = disp;
			 return 1;

		} default:return 0;
	}

}

int operand_is_float(const xed_operand_enum_t op_name) {
	switch (op_name) {
		/* Floating point registers */
	case XED_REG_X87CONTROL:
	case XED_REG_X87STATUS:
	case XED_REG_X87TOP:
	case XED_REG_X87TAG:
	case XED_REG_X87PUSH:
	case XED_REG_X87POP:
	case XED_REG_X87POP2:
		return 1;

		default:return 0;
	}
}

int operand_is_reg(const xed_operand_enum_t op_name, xed_reg_enum_t * reg_id) {
	switch (op_name) {
		/* Register */
	case XED_OPERAND_REG0:
	case XED_OPERAND_REG1:
	case XED_OPERAND_REG2:
	case XED_OPERAND_REG3:
	case XED_OPERAND_REG4:
	case XED_OPERAND_REG5:
	case XED_OPERAND_REG6:
	case XED_OPERAND_REG7:
	case XED_OPERAND_REG8:
	case XED_OPERAND_REG9:
	case XED_OPERAND_REG10:
	case XED_OPERAND_REG11:
	case XED_OPERAND_REG12:
	case XED_OPERAND_REG13:
	case XED_OPERAND_REG14:
	case XED_OPERAND_REG15:{
			*reg_id = xed_decoded_inst_get_reg(&xedd_g, op_name);
			return 1;
		} default:return 0;
	}
}
